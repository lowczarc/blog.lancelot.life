<!DOCTYPE html>
<html>
	<head>
		<title>Why you should take a look at functionnal programming - Lancelot Blog</title>
		<link rel="icon" type="image/png" href="/lancelot.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="/style.css" type="text/css" />
	</head>
	<body>
		<main>
			<header>
				<a href="/">
					<img id="logo" src="https://lancelot.life/lancelot.png" />
					<h1>Lancelot Owczarczak</h1>
				</a>
				<p>Guy who loves programming</p>
				<p>Rust Enthusiast</p>
				<p><a href="https://lancelot.life">About Me</a></p>
			</header>
			<section>
				<h1>Why you should take a look at functionnal programming</h1>
				<div id="publishing_date">Published on 22 January 2020</div>
				<div class="caution">
					<strong>Caution:</strong> I'm not a functionnal programming expert, I don't really know any fully functionnal programming language and I don't know most of the functionnal programming concepts. This article is just to explain why I find it interesting.
				</div>
				<p>
					Basically functionnal programming is a way of coding using only functions, without mutable variables.<br/>
					The first functionnal programming language is the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>:
				</p>
				<div class="code">The function for true: (λx.λy.x)
The function for false: (λx.λy.y)
The function for NOT: (λx.x((λx.λy.y), (λx.λy.x)))
The function for OR: (λx.λy.x((λx.λy.x)¸ y((λx.λy.x), (λx.λy.y))))
The function for AND: (λx.λy.x(y((λx.λy.x), (λx.λy.y)), (λx.λy.λy)))
The YCombinator: (λf.(λx.f(x, x))(λx.(f(x, x))))</div>
				<div class="subtitle">Even if it's theorically really interesting, the lambda calculus can be really hard to read</div>
				<p>
					In this language there wasn't any variable concept, everything is a function, but in most modern fully functionnal programming languages you can define constants and use numbers, arrays, etc...<br/>Although mutable variables aren't allowed.
				</p>
				<p>
					You can't use for/while loop (because it would use an iterator index) instead you have to use recursivity.
				</p>
				<h2>Advantages of functionnal programming</h2>
				<p>
					First, it makes programming look more like maths and I think that's beautiful. 😍
				</p>
				<p>
					If you want to add a line of code you can add it anywhere, in functionnal programming there are no side effects, you can't break your code by adding a line before another because they can't influence each other.
				</p>
				<div class="code">A = something()
// If you were to change the value of A here it would influence the value of B, because variables aren't mutable you can't do this in functionnal programming
B = something_else(A)</div>
				<p>
					Another really cool point: you can parallelize things really easily, if a constant doesn't use another constant in its definition (and reciprocally) you can do it in parallel and be sure they won't conflict with each other.
				</p>
				<div class="code">A = something1()
B = something2(A) // Here you can't compute A and B in parallel
C = a_slow_function(B)
D = an_other_slow_function(A) // Here you can compute C and D in parallel
E = something3(C, D)</div>
				<p>
					To know what you can compute in parallel you just have to draw a graph of the constant and draw an arrow between the constants and the other constants used in its definition.
				</p>
				<div class="code">A -> B -> C -> E
  \          /
   \----D---/</div>
				<p>
					We clearly see here that B and C can be computed in parallel of D
				</p>
				<h2>Downsides</h2>
				<p>
					Functionnal programming force us to make recursive algorithms instead of iterative ones, which can lead to a lack of performance.
				</p>
				<div class="code">fn recursive_fibo(n: u32) -> u32 {
	match n {
		0 | 1 => n,
		_ => recursive_fibo(n - 1) + recursive_fibo(n - 2),
	}
}

fn iterative_fibo(n: u32) -> u32 {
	let mut n_minus_1 = 0;
	let mut res = 1;

	if n < 2 {
		return n;
	}

	for _ in 1..n {
		let n_minus_2 = n_minus_1;
		n_minus_1 = res;
		res = n_minus_2 + n_minus_1;
	}
	res
}</div>
				<div class="code">Execution time recursive_fibo(42): 0m4.562s
Execution time iterative_fibo(42): 0m0.002s</div>
				<div class="subtitle">Even if the recursive one is much more beautiful, the iterative one is more performant</div>
				<h2>Conclusion</h2>
				<p>
					I will try to keep the functionnal programming concepts in mind, see where it's useful and doesn't make any/too much running speed difference and use it to think about parallelism.
				</p>
				<p>
					I really think it's a beautiful way of coding and even if I don't totally understand it yet I really want to use it to improve the way I think about programming.
				</p>
			</section>
		</main>
		<footer>
	</body>
</html>
